Absolute Zero Reasoner
│
├── 1. Motivation & Ziel
│   ├── Warum "Zero" Reasoner?
│   ├── Grenzen heutiger Reasoning-Ansätze
│   └── Neuer Paradigmenwechsel?
│
├── 2. Architektur
│   ├── Core Engine
│   │   ├── Logik / Beweisführung
│   │   ├── Constraint-Systeme
│   │   └── Symbolische Repräsentationen
│   ├── Input Layer
│   │   ├── Code
│   │   ├── Text
│   │   └── Abstrakte Formeln
│   └── Output Layer
│       ├── Beweise / Ableitungen
│       ├── Transformationen
│       └── Debugging-Infos
│
├── 3. Pipeline / Datenfluss
│   ├── Eingabe → Normalisierung
│   ├── Reasoning-Schritte
│   ├── Beweisbaum / Erklärung
│   └── Ausgabeformat
│
├── 4. Umsetzung
│   ├── Sprache & Frameworks
│   ├── Modulstruktur im Repo
│   ├── CLI / API / Service?
│   └── Beispiele / Tests
│
├── 5. Vergleich
│   ├── LLM-Reasoning (Chain-of-Thought)
│   ├── Symbolische Reasoner (z. B. Prolog, Z3)
│   └── Hybrid-Ansätze
│
├── 6. Für Rust interessant
│   ├── Typ-System-Checks
│   ├── Symbolisches Debugging
│   ├── Constraint Reasoner als Crate
│   └── Integration in Compiler / Toolchain
│
└── 7. Offene Fragen
    ├── Rechenaufwand / Skalierbarkeit
    ├── Erweiterbarkeit auf andere Sprachen
    ├── Kombination mit LLMs?
    └── Praktische Use-Cases
